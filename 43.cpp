#include <iostream> // в данный момент в файл печатается только t и y , чтобы это изменить поправьте строки 691 и 1054 B0 p_x p_y x y
#include <fstream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <bits/stdc++.h>
#include <chrono>
#include <time.h>
#include <stdio.h>
#define fac 0.9
#define facmin 0.7
#define facmax 3.6 // вот этот параметр контролирует рост шага
#define alpha 11// Сюда вводить 0 0.1 1 11
#define eps powl(10,-15)// тут точность для метода бисекции 15 хорошо 12 +- пойдет
#define eps1 powl(10,-9)// мелкость шага в X функции было 11
#define eps2 powl(10,-8)// дельта в производной



#define alpha_p_x_start 1.0215
#define alpha_p_y_start 1.0215
// размах метода Ньютона увеичивая здесь, увеличиваем диапазон поиска
#define maxcount1 100
#define maxcount 10

using namespace std;

long double dXpositive(double t,long double x,long double y ,long double p_x,long double p_y){
    return y;
}
long double dYpositive(double t,long double x,long double y ,long double p_x,long double p_y){
    return 1;//
}
long double dYnegative(double t,long double x,long double y ,long double p_x,long double p_y){
    return -1;
}
long double dPx(double t,long double x,long double y ,long double p_x,long double p_y){
    return 0;
}
long double dPy(double t,long double x,long double y ,long double p_x,long double p_y){
    return -p_x;
}
long double plusB(double t,long double x,long double y ,long double p_x,long double p_y){
    return 1./(1+alpha*t*t*t*t);
}
long double negativeB(double t,long double x,long double y ,long double p_x,long double p_y){
    return -1./(1+alpha*t*t*t*t);
}


int gauss (vector < vector<long double> > a, vector<long double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < pow(10,-10))
            continue;
        for (int i=col; i<=m; ++i)
        	swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }
    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > pow(10,-10))
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return 999999999;
    return 1;
}

double switchplus(double t,long double p_y) {

    return p_y -1.0/(1 + alpha*t*t*t*t);

}





void Set_of_K(long double *k1, long double *k2, long double *k3, long double *k4, long double *k5, long double *k6, long double *k7, long double &x, long double &y, long double &p_x, long double &p_y, double h, double &t){
    k1[0] = dXpositive(t,x,y,p_x,p_y);
    k1[1] = dYpositive(t,x,y,p_x,p_y);
    k1[2] = dYnegative(t,x,y,p_x,p_y);
    k1[3] = dPx       (t,x,y,p_x,p_y);
    k1[4] = dPy       (t,x,y,p_x,p_y);
    k1[5] = plusB(t,x,y,p_x,p_y);
    k1[6] = negativeB(t,x,y,p_x,p_y);


    k2[0] = dXpositive(t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[1] = dYpositive(t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[2] = dYnegative(t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[3] = dPx       (t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[4] = dPy       (t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[5] = plusB     (t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));
    k2[6] = negativeB (t + h * (1./5), x + k1[0] * (1./5), y + k1[1] * (1./5), p_x + k1[3] * (1./5), p_y + k1[4] * (1./5));


    k3[0] = dXpositive(t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[1] = dYpositive(t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[2] = dYnegative(t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[3] = dPx       (t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[4] = dPy       (t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[5] = plusB     (t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));
    k3[6] = negativeB (t + h * (3./10), x + h * ((3./40) * k1[0] + (9./40) * k2[0]), y + h * ((3./40) * k1[1] + (9./40) * k2[1]), p_x + h * ((3./40) * k1[3] + (9./40) * k2[3]), p_y + h * ((3./40) * k1[4] + (9./40) * k2[4]));



    k4[0] = dXpositive(t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[1] = dYpositive(t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[2] = dYnegative(t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[3] = dPx       (t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[4] = dPy       (t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[5] = plusB     (t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));
    k4[6] = negativeB (t + h * (4./5), x + h * ((44./45) * k1[0] - (56./15) * k2[0] + (32./9) * k3[0]), y + h * ((44./45) * k1[1] - (56./15) * k2[1] + (32./9) * k3[1]), p_x + h * ((44./45) * k1[3] - (56./15) * k2[3] + (32./9) * k3[3]), p_y + h * ((44./45) * k1[4] - (56./15) * k2[4] + (32./9) * k3[4]));

    k5[0] = dXpositive(t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[1] = dYpositive(t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[2] = dYnegative(t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[3] = dPx       (t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[4] = dPy       (t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[5] = plusB     (t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));
    k5[6] = negativeB (t + h * (8./9), x + h * ((19372./6561) * k1[0] - (25360./2187) * k2[0] + (64448./6561) * k3[0] - (212./729) * k4[0]), y + h * ((19372./6561) * k1[1] - (25360./2187) * k2[1] + (64448./6561) * k3[1] - (212./729) * k4[1]), p_x + h * ((19372./6561) * k1[3] - (25360./2187) * k2[3] + (64448./6561) * k3[3] - (212./729) * k4[3]), p_y + h * ((19372./6561) * k1[4] - (25360./2187) * k2[4] + (64448./6561) * k3[4] - (212./729) * k4[4]));



    k6[0] = dXpositive(t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[1] = dYpositive(t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[2] = dYnegative(t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[3] = dPx       (t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[4] = dPy       (t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[5] = plusB     (t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));
    k6[6] = negativeB (t + h, x + h * ((9017./3168) * k1[0] - (355./33) * k2[0] + (46732./5247) * k3[0] + (49./176) * k4[0] - (5103./18656) * k5[0]), y + h * ((9017./3168) * k1[1] - (355./33) * k2[1] + (46732./5247) * k3[1] + (49./176) * k4[1] - (5103./18656) * k5[1]), p_x + h * ((9017./3168) * k1[3] - (355./33) * k2[3] + (46732./5247) * k3[3] + (49./176) * k4[3] - (5103./18656) * k5[3]), p_y + h * ((9017./3168) * k1[4] - (355./33) * k2[4] + (46732./5247) * k3[4] + (49./176) * k4[4] - (5103./18656) * k5[4]));


    k7[0] = dXpositive(t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[1] = dYpositive(t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]),p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[2] = dYnegative(t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[3] = dPx       (t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[4] = dPy       (t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[5] = plusB     (t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));
    k7[6] = negativeB (t + h, x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]), y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]) ,p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]), p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]));

}


void Set_of_b(long double &b_1b_1,long double &b_b1x,long double &b_1x_1,long double &b_1x,long double &b_1y_1,long double &b_1y,long double &b_x, long double &b_x_1, long double &b_y, long double &b_y_1, long double &b_p_x, long double &b_p_x_1, long double &b_p_y, long double &b_p_y_1, long double *k1, long double *k2, long double *k3, long double *k4, long double *k5, long double *k6, long double *k7, long double &x, long double &y, long double &p_x, long double &p_y, long double &B0,double h){
	    b_x =   x + h * ((35./384) * k1[0] + (500./1113) * k3[0] + (125./192) * k4[0] - (2187./6784) * k5[0] + (11./84) * k6[0]);
	    b_x_1 = x + h * ((5179./57600) * k1[0] + (7571./16695) * k3[0] + (393./640) * k4[0] - (92097./339200) * k5[0] + (187./2100) * k6[0] + (1./40) * k7[0]);
	    b_y =   y + h * ((35./384) * k1[1] + (500./1113) * k3[1] + (125./192) * k4[1] - (2187./6784) * k5[1] + (11./84) * k6[1]);
	    b_y_1 = y + h * ((5179./57600) * k1[1] + (7571./16695) * k3[1] + (393./640) * k4[1] - (92097./339200) * k5[1] + (187./2100) * k6[1] + (1./40) * k7[1]);
	    b_1y =  y + h * ((35./384) * k1[2] + (500./1113) * k3[2] + (125./192) * k4[2] - (2187./6784) * k5[2] + (11./84) * k6[2]);
	    b_1y_1 =y + h * ((5179./57600) * k1[2] + (7571./16695) * k3[2] + (393./640) * k4[2] - (92097./339200) * k5[2] + (187./2100) * k6[2] + (1./40) * k7[2]);
	    b_p_x = p_x + h * ((35./384) * k1[3] + (500./1113) * k3[3] + (125./192) * k4[3] - (2187./6784) * k5[3] + (11./84) * k6[3]);
	    b_p_x_1 = p_x + h * ((5179./57600) * k1[3] + (7571./16695) * k3[3] + (393./640) * k4[3] - (92097./339200) * k5[3] + (187./2100) * k6[3] + (1./40) * k7[3]);
	    b_p_y = p_y + h * ((35./384) * k1[4] + (500./1113) * k3[4] + (125./192) * k4[4] - (2187./6784) * k5[4] + (11./84) * k6[4]);
	    b_p_y_1 = p_y + h * ((5179./57600) * k1[4] + (7571./16695) * k3[4] + (393./640) * k4[4] - (92097./339200) * k5[4] + (187./2100) * k6[4] + (1./40) * k7[4]);
	    b_1x =   B0 + h * ((35./384) * k1[5] + (500./1113) * k3[5] + (125./192) * k4[5] - (2187./6784) * k5[5] + (11./84) * k6[5]);
	    b_1x_1 = B0 + h * ((5179./57600) * k1[5] + (7571./16695) * k3[5] + (393./640) * k4[5] - (92097./339200) * k5[5] + (187./2100) * k6[5] + (1./40) * k7[5]);
	    b_b1x =   B0 + h * ((35./384) * k1[6] + (500./1113) * k3[6] + (125./192) * k4[6] - (2187./6784) * k5[6] + (11./84) * k6[6]);
	    b_1b_1 = B0 + h * ((5179./57600) * k1[6] + (7571./16695) * k3[6] + (393./640) * k4[6] - (92097./339200) * k5[6] + (187./2100) * k6[6] + (1./40) * k7[6]);

}

long double X_function(long double x, long double y, long double p_x, long double p_y, double T, int p){
    long double k1[7], k2[7], k3[7], k4[7], k5[7], k6[7], k7[7], err = 0, tol =eps1;
    long double b_x, b_x_1, b_y, b_y_1,b_p_x, b_p_x_1, b_p_y, b_p_y_1, b_1x_1, b_1x,b_1y_1, b_1y,Qb_p_y, Qp_y,a ;
    long double b_1b_1;
    long double b_b1x;
    long double B0=0;

    double h = 0.1, t = 0.0,t2=0,t1=0;



    while(t <= (T-h)){




                  Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                  Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                  err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

                  if (err <= tol){


                  	 if(switchplus(t,p_y)*switchplus(t+h,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге

                  		 {

                  			 t1=t;
                  			 t2=t+h;
                  			 Qb_p_y= b_p_y;
                  			 Qp_y=p_y;



                  			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
                  		               		 	{
                  		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
                  		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

                  		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

                  		               		 			break;}
                  		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


                  		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
                  		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
                  		                                   Qp_y=b_p_y;// перенесли
                  		                                   t1 = (t2 + t1) / 2;

                  		               		 		}
                  		               		 		else{
                  		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

                  		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
                  		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
                  		                                   Qb_p_y=b_p_y;
                  		                                   t2 = (t1+t2) / 2;
                  		               		 		}
                  		               		 	}


                  		 h=abs((t-(t2+t1) / 2));
                  		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                  		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                  	 a= switchplus(t,p_y);



                    if(a>0){ // ( если старый был больше 0 то до точки переключения идем с положительным управлением с

                  	                      		//x = b_1x;

                  	                      		y = b_y;
                  	                      		p_x = b_p_x;
                  	                      		p_y = b_p_y;
                                               B0=b_1x;
                  	                      		t += h;
                                               x = b_x;

                  	                      		h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
           //использую а иначе следующий if срабатывает
                                        	         		                	        		}

                    if(a<0){ // если теперь больше нуля и было переключения, значит до было меньше


                            	                      		//x = b_1x;

                            	                      		y = b_1y;
                            	                      		p_x = b_p_x;
                            	                      		p_y = b_p_y;
                                                           B0=b_b1x;
                            	                      	    t+=h;
                            	                      	 Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                                        Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);

                            	                      	    x = b_x;
                                                          h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));


                  	}
                  		 }}
                  	else{

                              	         		                	if(switchplus(t,p_y)>0){ // переключения нет значит старый  переключатель такого же знака, что и новый


                              	         		                	        		y = b_y;
                              	         		                	        		p_x = b_p_x;
                              	         		                	        		p_y = b_p_y;
                              	         		                	        	    B0=b_1x;
                              	         		                	        		t += h;

                              	         		                	        		x = b_x;
                              	         		                	        		 h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
                              	         		                	        		}


                              	         		                	        	         		                else if (switchplus(t,p_y)<0){




                              	         		                	        	         		                	        	    y = b_1y;
                              	         		                	        	         		                	        		p_x = b_p_x;
                              	         		                	        	         		                	        		p_y = b_p_y;
                              	         		                	        	         		                	        	    B0=b_b1x;
                              	         		                	        	         		                	        		t += h;
                              	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                              	         		                	        	         		                	        		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                              	         		                	        	         		                	        		x = b_x;

                              	         		                	        	         		                	        		h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
                              	         		                	        	         		                	        		}
                  }}
                  else{
                      while(err > tol){
                          h = h * fmin (1., fmax( facmin , fac * powl((tol/err), 1./6)));
                          Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                          Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                          err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

                      }



                      if(switchplus(t,p_y)*switchplus(t+h,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге
                             		  // функция, которая ищет ноль на промежутке от a до b
                             		 {
                             			 t1=t;
                             			 t2=t+h;
                             			 Qb_p_y= b_p_y;
                             			 Qp_y=p_y;



                             			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
                             			               		               		 	{
                             			               		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
                             			               		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

                             			               		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

                             			               		               		 			break;}
                             			               		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


                             			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
                             			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
                             			               		                                   Qp_y=b_p_y;// перенесли
                             			               		                                   t1 = (t2 + t1) / 2;

                             			               		               		 		}
                             			               		               		 		else{
                             			               		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

                             			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
                             			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
                             			               		                                   Qb_p_y=b_p_y;
                             			               		                                   t2 = (t1+t2) / 2;
                             			               		               		 		}
                             			               		               		 	}


                             			h=abs((t-(t2+t1) / 2));
                              		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                              		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);


                                if(switchplus(t,p_y)>0){ // если теперь больше нуля и было переключения, значит до было меньше

                              	                      		//x = b_1x;

                              	                      		y = b_y;
                              	                      		p_x = b_p_x;
                              	                      		p_y = b_p_y;
                              	                      	    B0=b_1x;
                              	                      		t += h;

                              	                      		x = b_x;
          	}

                                if(switchplus(t,p_y)<0){ // если теперь больше нуля и было переключения, значит до было меньше




                                        	                      		y = b_1y;
                                        	                      		p_x = b_p_x;
                                        	                      		p_y = b_p_y;
                                        	                      		B0=b_b1x;
                                        	                      	    t+=h;
                                        	                      	 Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                        	                      	Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                                        	                      	x = b_x;
                                }
                             		 }}
                              	else{

                                          	         		                	if(switchplus(t+h,b_p_y)>0){ // переключения нет


                                          	         		                	        		y = b_y;
                                          	         		                	        		p_x = b_p_x;
                                          	         		                	        		p_y = b_p_y;
                                          	         		                	        	    B0=b_1x;
                                          	         		                	        		t += h;

                                          	         		                	        		x = b_x;

                                          	         		                	        		}


                                          	         		                	        	         		                else if (switchplus(t+h,b_p_y)<0){




                                          	         		                	        	         		                	        	    y = b_1y;
                                          	         		                	        	         		                	        		p_x = b_p_x;
                                          	         		                	        	         		                	        		p_y = b_p_y;
                                          	         		                	        	         		                	        	    B0=b_b1x;
                                          	         		                	        	         		                	        		t += h;
                                          	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                          	         		                	        	         		                	        		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                                          	         		                	        	         		                	        		x = b_x;
                                          	         		                	        	         		                	        		}
                              }}}

               h = T - t;
               t = T;


               Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
               Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);

               err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

               if(switchplus(t-h,p_y)*switchplus(t,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге
                      		  // функция, которая ищет ноль на промежутке от a до b
                      		 {
                      			 t1=t-h;
                      			 t2=t;
                      			 Qb_p_y= b_p_y;
                      			 Qp_y=p_y;



                      			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
                      			               		               		 	{
                      			               		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
                      			               		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

                      			               		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

                      			               		               		 			break;}
                      			               		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


                      			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
                      			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
                      			               		                                   Qp_y=b_p_y;// перенесли
                      			               		                                   t1 = (t2 + t1) / 2;

                      			               		               		 		}
                      			               		               		 		else{
                      			               		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

                      			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
                      			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
                      			               		                                   Qb_p_y=b_p_y;
                      			               		                                   t2 = (t1+t2) / 2;
                      			               		               		 		}
                      			               		               		 	}


                      			h=abs((t-(t2+t1) / 2));
                       		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                       		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);



                         if(switchplus(t,p_y)>0){ // если теперь больше нуля и было переключения, значит до было меньше



                       	                      		y = b_y;
                       	                      		p_x = b_p_x;
                       	                      		p_y = b_p_y;
                       	                      		x = b_x;
                       	                      		B0=b_1x;
                       	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, 1-h, t);
                       	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                       	                      		y = b_1y;
                       	                      		p_x = b_p_x;
                       	                      		p_y = b_p_y;
                       	                      		B0=b_b1x;
                       	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y,1-h, t);
                       	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                       	                      		x = b_x;




                                             	         		                	        		}

                         if(switchplus(t,p_y)<0){ // если теперь больше нуля и было переключения, значит до было меньше

                      	                                                y = b_1y;
                      	                	                      		p_x = b_p_x;
                      	                	                      		p_y = b_p_y;
                      	                	                      	   B0=b_b1x;

                      	                	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y,1-h, t);
                      	                	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                      	                	                      		x = b_x;
                      	                	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, 1-h, t);
                      	                	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                      	                	                      		y = b_y;
                      	                	                      		p_x = b_p_x;
                      	                	                      		p_y = b_p_y;
                      	                	                         	B0=b_1x;

                      	                                                x = b_x;



                       	}}}
               else{

                                   	         		                	if(switchplus(t,p_y)>0){ // переключения нет


                                   	         		                	        		y = b_y;
                                   	         		                	        		p_x = b_p_x;
                                   	         		                	        		p_y = b_p_y;
                                   	         		                	        		B0=b_1x;

                                   	         		                	        		x = b_x;

                                   	         		                	        		}


                                   	         		                	        	         		                else if (switchplus(t,p_y)<0){




                                   	         		                	        	         		                	        	    y = b_1y;
                                   	         		                	        	         		                	        		p_x = b_p_x;
                                   	         		                	        	         		                	        		p_y = b_p_y;
                                   	         		                	        	         		                	        		B0=b_b1x;

                                   	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                   	         		                	        	         		                	        		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                                   	         		                	        	         		                	        		x = b_x;


                                   	         		                	        	         		                	        		}}
         if (p == 0) //
             return fabs(p_y); // условие на конце
         else
             return fabs(x +0.45833333333333333333); // услвоие на конце




}

int main()
{
	ofstream output("mi.txt");

    long double  delta = eps2;
    int count = 1;
    int count_1 = 1;
    long double alpha_p_x = alpha_p_x_start;
    long double alpha_p_y = alpha_p_y_start;
    long double X_1, X_2, X_3, X_4;
// метод Стрельбы




    while (count_1 < maxcount1){

    	 if (powl( X_function(0.0, 0.0, alpha_p_x, alpha_p_y, 1.0, 0), 2) + powl(X_function(0.0, 0.0, alpha_p_x, alpha_p_y, 1.0, 1), 2)   < powl(10,-14))// когда здесь 8 было все работало
    	 {
    		  cout << " Результаты метода стрельбы: " << endl;
     	                cout << "p_x(0)=" << fixed<< setprecision(20)  << alpha_p_x << endl;

    	                cout << "p_y(0)=" << fixed<< setprecision(20)  << alpha_p_y << endl;


    	                goto link;
    	            }
    	            else{


    	                X_1 = (X_function(0.0, 0.0,   alpha_p_x + delta, alpha_p_y,  1.0, 0) - X_function(0.0, 0.0,  alpha_p_x, alpha_p_y,   1.0, 0))/delta; //это производная
    	                X_2 = (X_function(0.0, 0.0,   alpha_p_x, alpha_p_y + delta,   1.0, 0) - X_function(0.0, 0.0,   alpha_p_x, alpha_p_y  , 1.0, 0))/delta;

    	                X_3 = (X_function(0.0, 0.0,   alpha_p_x + delta, alpha_p_y,  1.0, 1) - X_function(0.0, 0.0,  alpha_p_x, alpha_p_y,   1.0, 1))/delta; //это производная
    	                X_4 = (X_function(0.0, 0.0,   alpha_p_x, alpha_p_y + delta,   1.0, 1) - X_function(0.0, 0.0,   alpha_p_x, alpha_p_y,   1.0, 1))/delta;

// cout << X_1 << " " << X_2 << " " << X_3 << " " << X_4 <<endl;
 //cout << powl(X_function(0.0, 0.0, alpha_p_x, alpha_p_y, 1.0, 0), 2) + powl(X_function(0.0, 0.0, alpha_p_x, alpha_p_y, 1.0, 1), 2) <<" ждем пока меньше 10-16 будет" << endl;

    	                long double alpha_p_x1 = alpha_p_x;
    	                long double alpha_p_y1 = alpha_p_y;


    	                long double y1 = X_function(0.0, 0.0,   alpha_p_x, alpha_p_y,  1.0, 0);
    	                long double y2 = X_function(0.0, 0.0,  alpha_p_x, alpha_p_y,   1.0, 1);


    	                long double h3;
    	                long double h4;



    	                vector <long double> ans(2);
    	                vector < vector<long double> > a = { {X_1,X_2,-y1},{X_3,X_4,-y2}};

               gauss(a,ans);

               h3 = ans[0];
               h4 = ans[1];

                             alpha_p_x = alpha_p_x + h3;
                             alpha_p_y = alpha_p_y + h4;



                while( ((powl(X_function(0.0, 0.0, alpha_p_x, alpha_p_y , 1.0, 0), 2)+ powl(X_function(0.0, 0.0,  alpha_p_x, alpha_p_y , 1.0, 1), 2))
>= (powl(X_function(0.0, 0.0,  alpha_p_x1, alpha_p_y1 , 1.0, 0), 2)+ powl(X_function(0.0, 0.0,  alpha_p_x1, alpha_p_y1 , 1.0, 1), 2))) && count < maxcount){

                    alpha_p_x = alpha_p_x1;
                    alpha_p_y = alpha_p_y1;
                    alpha_p_x = alpha_p_x + h3 * 1./(2 * count);
                    alpha_p_y = alpha_p_y + h4 * 1./(2 * count);
                    count ++;
                }
            }


        count_1 ++;
        }


    cout << "NO solutions" << endl;
    cout << "alpha_p_x " << endl;
    cout << fixed<< setprecision(20) << alpha_p_x << endl;
    cout << "alpha_p_y" << endl;
    cout << fixed<< setprecision(20) << alpha_p_y << endl;




    return 0;

    link:

    long double k1[7], k2[7], k3[7], k4[7], k5[7], k6[7], k7[7], err = 0.0, tol = eps1;
    long double b_x, b_x_1, b_y, b_y_1,b_p_x, b_p_x_1, b_p_y, b_p_y_1, b_1x_1, b_1x,b_1y_1, b_1y,Qb_p_y, Qp_y ;
    long double a;

    long double b_1b_1;
    long double b_b1x;
    double h = 0.1 , t = 0.0,t2=0,t1=0,t3=0;
    long double T = 1;

    long double x = 0.0, y = 0.0, p_x = alpha_p_x, p_y =alpha_p_y;// сюда переходят результаты метода стрельбы



    long double B0=0;


    while(t <= (T-h)){


       output << fixed<< setprecision(20) << t <<" " << B0  <<endl;
           	 //output << t <<"     " << y  <<endl;
               Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
               Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
               err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

               if (err <= tol){


               	 if(switchplus(t,p_y)*switchplus(t+h,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге

               		 {

               			 t1=t;
               			 t2=t+h;
               			 Qb_p_y= b_p_y;
               			 Qp_y=p_y;



               			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
               		               		 	{
               		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
               		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

               		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

               		               		 			break;}
               		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
               		                                   Qp_y=b_p_y;// перенесли
               		                                   t1 = (t2 + t1) / 2;

               		               		 		}
               		               		 		else{
               		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
               		                                   Qb_p_y=b_p_y;
               		                                   t2 = (t1+t2) / 2;
               		               		 		}
               		               		 	}

if(abs((t1+t2) / 2 -t3) >=powl(10,-12) ){
 cout<<fixed << setprecision(20) << " координаты переключения  t=  " << (t1+t2) / 2 << endl;
}
               		 h=abs((t-(t2+t1) / 2));
               		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
               		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
               	 a= switchplus(t,p_y);
               	t3=(t1+t2) / 2;



                 if(a>0){ // ( если старый был больше 0 то до точки переключения идем с положительным управлением с

               	                      		//x = b_1x;

               	                      		y = b_y;
               	                      		p_x = b_p_x;
               	                      		p_y = b_p_y;
                                            B0=b_1x;
               	                      		t += h;
                                            x = b_x;

               	                      		h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
        //использую а иначе следующий if срабатывает
                                     	         		                	        		}

                 if(a<0){ // если теперь больше нуля и было переключения, значит до было меньше


                         	                      		//x = b_1x;

                         	                      		y = b_1y;
                         	                      		p_x = b_p_x;
                         	                      		p_y = b_p_y;
                                                        B0=b_b1x;
                         	                      	    t+=h;
                         	                      	 Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                                     Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);

                         	                      	    x = b_x;
                                                       h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));


               	}
               		 }}
               	else{

                           	         		                	if(switchplus(t,p_y)>0){ // переключения нет значит старый  переключатель такого же знака, что и новый


                           	         		                	        		y = b_y;
                           	         		                	        		p_x = b_p_x;
                           	         		                	        		p_y = b_p_y;
                           	         		                	        	    B0=b_1x;
                           	         		                	        		t += h;

                           	         		                	        		x = b_x;
                           	         		                	        		 h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
                           	         		                	        		}


                           	         		                	        	         		                else if (switchplus(t,p_y)<0){


                           	         		                	        	         		                	        	  //x = b_1x;

                           	         		                	        	         		                	        	    y = b_1y;
                           	         		                	        	         		                	        		p_x = b_p_x;
                           	         		                	        	         		                	        		p_y = b_p_y;
                           	         		                	        	         		                	        	    B0=b_b1x;
                           	         		                	        	         		                	        		t += h;
                           	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                           	         		                	        	         		                	        		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                           	         		                	        	         		                	        		x = b_x;

                           	         		                	        	         		                	        		h = h * fmin (facmax, fmax( facmin, fac * powl((tol/err), 1./6)));
                           	         		                	        	         		                	        		}
               }}
               else{
                   while(err > tol){
                       h = h * fmin (1., fmax( facmin , fac * powl((tol/err), 1./6)));
                       Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                       Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                       err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

                   }



                   if(switchplus(t,p_y)*switchplus(t+h,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге
                          		  // функция, которая ищет ноль на промежутке от a до b
                          		 {
                          			 t1=t;
                          			 t2=t+h;
                          			 Qb_p_y= b_p_y;
                          			 Qp_y=p_y;



                          			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
                          			               		               		 	{
                          			               		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
                          			               		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

                          			               		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

                          			               		               		 			break;}
                          			               		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


                          			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
                          			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
                          			               		                                   Qp_y=b_p_y;// перенесли
                          			               		                                   t1 = (t2 + t1) / 2;

                          			               		               		 		}
                          			               		               		 		else{
                          			               		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

                          			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
                          			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
                          			               		                                   Qb_p_y=b_p_y;
                          			               		                                   t2 = (t1+t2) / 2;
                          			               		               		 		}
                          			               		               		 	}


                           		 h=abs(t-(t2+t1) / 2);
                           		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                           		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);


                             if(switchplus(t,p_y)>0){ // если теперь больше нуля и было переключения, значит до было меньше

                           	                      		//x = b_1x;

                           	                      		y = b_y;
                           	                      		p_x = b_p_x;
                           	                      		p_y = b_p_y;
                           	                      	    B0=b_1x;
                           	                      		t += h;

                           	                      		x = b_x;
       	}

                             if(switchplus(t,p_y)<0){ // если теперь больше нуля и было переключения, значит до было меньше


                                     	                      		//x = b_1x;

                                     	                      		y = b_1y;
                                     	                      		p_x = b_p_x;
                                     	                      		p_y = b_p_y;
                                     	                      		B0=b_b1x;
                                     	                      	    t+=h;
                                     	                      	 Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                     	                      	Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);

                                     	                      	x = b_x;}
                          		 }}
                           	else{

                                       	         		                	if(switchplus(t+h,b_p_y)>0){ // переключения нет


                                       	         		                	        		y = b_y;
                                       	         		                	        		p_x = b_p_x;
                                       	         		                	        		p_y = b_p_y;
                                       	         		                	        	    B0=b_1x;
                                       	         		                	        		t += h;
                                       	         		                	        		x = b_x;

                                       	         		                	        		}


                                       	         		                	        	         		                else if (switchplus(t+h,b_p_y)<0){




                                       	         		                	        	         		                	        	    y = b_1y;
                                       	         		                	        	         		                	        		p_x = b_p_x;
                                       	         		                	        	         		                	        		p_y = b_p_y;
                                       	         		                	        	         		                	        	    B0=b_b1x;
                                       	         		                	        	         		                	        		t += h;
                                       	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                       	         		                	        	         		                	        		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                                       	         		                	        	         		                	        		x = b_x;
                                       	         		                	        	         		                	        		}
                           }}}

            h = T - t;
            t = T;


            Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
            Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);

            err = fmax( fmax(abs(b_1y_1 - b_1y),abs( b_1x_1 -  b_1x)),fmax(fmax(abs(b_x_1 - b_x),abs(b_y_1 - b_y)),fmax(fmax(abs(b_p_x_1 - b_p_x),abs(b_p_y_1 - b_p_y)),abs( b_1b_1 -  b_b1x))));

            if(switchplus(t-h,p_y)*switchplus(t,b_p_y)<=0){// критерий существования корня(смены управления) на допустимом шаге
                   		  // функция, которая ищет ноль на промежутке от a до b
                   		 {
                   			 t1=t-h;
                   			 t2=t;
                   			 Qb_p_y= b_p_y;
                   			 Qp_y=p_y;

                   			 cout << endl;
                   			while (t2-t1 > eps) // пока не будет достигнута необходимая точность
                   			               		               		 	{
                   			               		               		 		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);
                   			               		               		 		Set_of_b( b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, Qb_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);

                   			               		               		 		if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) == 0){ // произведение функции в середине отрезка и в начальной точке t1

                   			               		               		 			break;}
                   			               		               		 		else if (switchplus(t1,Qp_y) * switchplus((t2+t1)/2,Qb_p_y) > 0){ // если больше, то мы на промежутке от середина до t2


                   			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, Qp_y, (t2-t1)/2, t1);//мы на (t1+t2)/2 t2  , переносим t1 в точку (t1+t2)/2
                   			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, Qp_y,B0,(t2-t1)/2);
                   			               		                                   Qp_y=b_p_y;// перенесли
                   			               		                                   t1 = (t2 + t1) / 2;

                   			               		               		 		}
                   			               		               		 		else{
                   			               		               		 		//мы на t1 (t1+t2)/2   , переносим t2 в точку (t1+t2)/2

                   			               		               		 			Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, (t1+t2)/2, t1);
                   			               		               		 			Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,(t1+t2)/2);
                   			               		                                   Qb_p_y=b_p_y;
                   			               		                                   t2 = (t1+t2) / 2;
                   			               		               		 		}
                   			               		               		 	}


                    		 h=t2-(t2+t1) / 2;
                    		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                    		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);


                      if(switchplus(t,p_y)>0){ // если теперь больше нуля и было переключения, значит до было меньше



                    	                      		y = b_y;
                    	                      		p_x = b_p_x;
                    	                      		p_y = b_p_y;
                    	                      		x = b_x;
                    	                      		B0=b_1x;
                    	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, 1-h, t);
                    	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                    	                      		y = b_1y;
                    	                      		p_x = b_p_x;
                    	                      		p_y = b_p_y;
                    	                      		B0=b_b1x;
                    	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y,1-h, t);
                    	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                    	                      		x = b_x;
}

                      if(switchplus(t,p_y)<0){ // если теперь больше нуля и было переключения, значит до было меньше

                   	                                                y = b_1y;
                   	                	                      		p_x = b_p_x;
                   	                	                      		p_y = b_p_y;
                   	                	                      	   B0=b_b1x;

                   	                	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y,1-h, t);
                   	                	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                   	                	                      		x = b_x;
                   	                	                      		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, 1-h, t);
                   	                	                      		Set_of_b(b_1b_1, b_b1x, b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,1-h);
                   	                	                      		y = b_y;
                   	                	                      		p_x = b_p_x;
                   	                	                      		p_y = b_p_y;
                   	                	                         	B0=b_1x;

                   	                                                x = b_x;



                    	}}}
            else{

                                	         		                	if(switchplus(t,p_y)>0){ // переключения нет


                                	         		                	        		y = b_y;
                                	         		                	        		p_x = b_p_x;
                                	         		                	        		p_y = b_p_y;
                                	         		                	        		B0=b_1x;

                                	         		                	        		x = b_x;

                                	         		                	        		}


                                	         		                	        	         		                else if (switchplus(t,p_y)<0){




                                	         		                	        	         		                	        	    y = b_1y;
                                	         		                	        	         		                	        		p_x = b_p_x;
                                	         		                	        	         		                	        		p_y = b_p_y;
                                	         		                	        	         		                	        		B0=b_b1x;

                                	         		                	        	         		                	        		Set_of_K(k1, k2, k3, k4, k5, k6, k7, x, y, p_x, p_y, h, t);
                                	         		                	        	         		                	        		Set_of_b( b_1b_1, b_b1x,b_1x_1, b_1x,b_1y_1,b_1y,b_x, b_x_1, b_y, b_y_1, b_p_x, b_p_x_1, b_p_y, b_p_y_1, k1, k2, k3, k4, k5, k6, k7, x, y,p_x, p_y,B0,h);
                                	         		                	        	         		                	        		x = b_x;


                                	         		                	        	         		                	        		}}
 	//output << fixed<< setprecision(20) << t <<" " << x <<" " << y  << " " << p_x  << " " << p_y<< " "  << B_0 <<endl;
            output << fixed<< setprecision(20) << t <<" " << B0  <<endl;
     //output << t << "  " << x << endl;// тут печатается  последний шаг
 	//output << fixed<< setprecision(20) << t <<" " << y  <<endl;
  cout << "Параметр альфа = " << alpha << endl;
  cout << "Значения в t= 1: " << endl;
         cout << fixed<< setprecision(20) <<"x" <<" = "<<  x << endl;
         cout << fixed<< setprecision(20)<< "y" << " = "<< y << endl;
         cout << fixed<< setprecision(20)<< "p_x" <<" = "<<p_x << endl;
         cout << fixed<< setprecision(20)<< "p_y" <<" = "<< p_y << endl;

    return 0;
}
